<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gestion Base de Données - FirePoz</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    .toast-in { animation: toastIn 0.5s both; }
    .toast-out { animation: toastOut 0.5s both; }
    @keyframes toastIn { from { opacity:0; transform:translateY(40px);} to { opacity:1; transform:translateY(0);} }
    @keyframes toastOut { from { opacity:1; transform:translateY(0);} to { opacity:0; transform:translateY(40px);} }
    .loading { opacity: 0.5; pointer-events: none; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen">

  <!-- ⚡ Gestionnaire IndexedDB amélioré -->
  <script>
    class IndexedDBStorage {
      constructor() {
        this.DB_NAME = "FirePozDB";
        this.STORE_NAME = "keyvalue";
        this.dbPromise = null;
        this.cache = {};
        this.initialized = false;
        this.initPromise = null;
      }

      async init() {
        if (this.initPromise) return this.initPromise;
        
        this.initPromise = new Promise(async (resolve, reject) => {
          try {
            // Initialiser la base IndexedDB
            this.dbPromise = new Promise((resolve, reject) => {
              const req = indexedDB.open(this.DB_NAME, 1);
              req.onupgradeneeded = e => {
                e.target.result.createObjectStore(this.STORE_NAME);
              };
              req.onsuccess = e => resolve(e.target.result);
              req.onerror = e => reject(e);
            });

            // Charger les données dans le cache
            const keys = ["gestion_db", "gestion_db_list", "gestion_db_active", "apiBaseUrl"];
            for (let k of keys) {
              let val = await this.getFromIDB(k);
              if (val !== null) this.cache[k] = val;
            }
            
            this.initialized = true;
            resolve();
          } catch (error) {
            reject(error);
          }
        });

        return this.initPromise;
      }

      async getFromIDB(key) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readonly");
          const store = tx.objectStore(this.STORE_NAME);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = reject;
        });
      }

      async setToIDB(key, value) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readwrite");
          const store = tx.objectStore(this.STORE_NAME);
          store.put(value, key);
          tx.oncomplete = () => resolve(true);
          tx.onerror = reject;
        });
      }

      async removeFromIDB(key) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readwrite");
          const store = tx.objectStore(STORE_NAME);
          store.delete(key);
          tx.oncomplete = () => resolve(true);
          tx.onerror = reject;
        });
      }

      // Interface synchrone (utilise le cache)
      getItem(key) {
        return this.cache[key] || null;
      }

      setItem(key, value) {
        this.cache[key] = value;
        // Sauvegarder asynchrone en arrière-plan
        this.setToIDB(key, value).catch(console.error);
      }

      removeItem(key) {
        delete this.cache[key];
        this.removeFromIDB(key).catch(console.error);
      }

      // Méthodes async pour les opérations importantes
      async setItemAsync(key, value) {
        this.cache[key] = value;
        await this.setToIDB(key, value);
      }

      async removeItemAsync(key) {
        delete this.cache[key];
        await this.removeFromIDB(key);
      }
    }

    // Instance globale
    window.idbStorage = new IndexedDBStorage();
    
    // Patch localStorage pour compatibilité
    const originalLocalStorage = window.localStorage;
    window.localStorage = {
      getItem: (k) => window.idbStorage.getItem(k),
      setItem: (k, v) => window.idbStorage.setItem(k, v),
      removeItem: (k) => window.idbStorage.removeItem(k),
      // Méthodes async
      setItemAsync: (k, v) => window.idbStorage.setItemAsync(k, v),
      removeItemAsync: (k) => window.idbStorage.removeItemAsync(k)
    };
  </script>

  <!-- Navbar -->
  <nav class="bg-indigo-600 text-white p-4 shadow-md">
    <div class="container mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-bold">
        <i class="fas fa-database mr-2"></i>Gestion Base de Données
      </h1>
      <button onclick="goHome()" class="bg-white text-indigo-600 px-4 py-2 rounded-md hover:bg-gray-200">
        <i class="fas fa-home mr-2"></i>Accueil
      </button>
    </div>
  </nav>

  <div class="container mx-auto px-4 py-8">
    <!-- Indicateur de chargement -->
    <div id="loadingIndicator" class="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded mb-4">
      <i class="fas fa-spinner fa-spin mr-2"></i>Initialisation en cours...
    </div>

    <!-- Gestion Base de Données -->
    <div id="mainContent" class="loading">
      <div class="bg-white rounded-lg shadow-md p-6 mb-8">
        <h2 class="text-xl font-semibold mb-4">
          <i class="fas fa-database mr-2 text-indigo-500"></i>Outils Base de Données
        </h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <button onclick="downloadDatabase()" class="w-full bg-green-600 text-white px-4 py-3 rounded-md hover:bg-green-700 transition">
            <i class="fas fa-file-download mr-2"></i>Télécharger gestion.db
          </button>
          <button onclick="resetDatabase()" class="w-full bg-red-600 text-white px-4 py-3 rounded-md hover:bg-red-700 transition">
            <i class="fas fa-trash mr-2"></i>Réinitialiser la Base
          </button>
          <label class="w-full bg-blue-600 text-white px-4 py-3 rounded-md hover:bg-blue-700 transition text-center cursor-pointer">
            <i class="fas fa-upload mr-2"></i>Charger depuis fichier
            <input type="file" id="uploadDb" accept=".db,.sqlite,.sqlite3" class="hidden" onchange="uploadDatabase(event)">
          </label>
          <button onclick="createNewDatabase()" class="w-full bg-indigo-600 text-white px-4 py-3 rounded-md hover:bg-indigo-700 transition">
            <i class="fas fa-plus-circle mr-2"></i>Nouvelle Base (vierge)
          </button>
          <button onclick="updateFromServer()" class="w-full bg-yellow-600 text-white px-4 py-3 rounded-md hover:bg-yellow-700 transition">
            <i class="fas fa-cloud-download-alt mr-2"></i>Mettre à jour depuis serveur
          </button>
        </div>
        <div class="mt-4 text-sm text-gray-600">
          <p><i class="fas fa-info-circle mr-2"></i>La base de production est stockée dans IndexedDB</p>
          <p id="dbSize" class="mt-2">Taille: Calcul en cours...</p>
        </div>
      </div>

      <!-- Liste des bases sauvegardées -->
      <div class="bg-white rounded-lg shadow-md p-6">
        <h2 class="text-xl font-semibold mb-4">
          <i class="fas fa-archive mr-2 text-indigo-500"></i>Bases Sauvegardées
        </h2>
        <ul id="dbList" class="space-y-3"></ul>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="fixed bottom-4 right-4 hidden">
    <div class="flex items-center px-6 py-3 rounded-md shadow-lg">
      <i id="toastIcon" class="mr-2"></i>
      <span id="toastMessage"></span>
    </div>
  </div>

  <script>
    let APP_INITIALIZED = false;

    async function initializeApp() {
      try {
        // Initialiser IndexedDB
        await window.idbStorage.init();
        
        // Masquer l'indicateur de chargement
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('mainContent').classList.remove('loading');
        
        APP_INITIALIZED = true;
        
        // Initialiser l'interface
        updateDBSize();
        renderDbList();
        
        showToast("Application initialisée avec succès");
      } catch (error) {
        console.error('Erreur d\'initialisation:', error);
        showToast("Erreur d'initialisation: " + error.message, true);
      }
    }

    const API_BASE_URL = localStorage.getItem('apiBaseUrl') || 'https://hicham03041979.onrender.com';

    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toastMessage');
      const toastIcon = document.getElementById('toastIcon');
      toast.className = isError
        ? 'fixed bottom-4 right-4 flex items-center bg-red-500 text-white px-6 py-3 rounded-md shadow-lg toast-in'
        : 'fixed bottom-4 right-4 flex items-center bg-green-500 text-white px-6 py-3 rounded-md shadow-lg toast-in';
      toastIcon.className = isError ? 'fas fa-exclamation-circle mr-2' : 'fas fa-check-circle mr-2';
      toastMessage.textContent = message;
      toast.classList.remove('hidden');
      setTimeout(() => {
        toast.classList.remove('toast-in');
        toast.classList.add('toast-out');
        setTimeout(() => toast.classList.add('hidden'), 500);
      }, 3000);
    }

    function isDbFile(name) { return /\.(db|sqlite|sqlite3)$/i.test(name); }
    function goHome() { window.location.href = "index.html"; }
    function getDbList() { return JSON.parse(localStorage.getItem("gestion_db_list") || "[]"); }
    
    async function saveDbList(list) { 
      await localStorage.setItemAsync("gestion_db_list", JSON.stringify(list)); 
    }
    
    function getActiveIndex() { return parseInt(localStorage.getItem("gestion_db_active") || "-1"); }
    
    async function setActiveIndex(idx) { 
      await localStorage.setItemAsync("gestion_db_active", idx.toString()); 
    }

    // Vérifier l'initialisation avant les actions
    function checkInitialized() {
      if (!APP_INITIALIZED) {
        showToast("Application en cours d'initialisation...", true);
        return false;
      }
      return true;
    }

    async function downloadDatabase() {
      if (!checkInitialized()) return;
      
      const dbData = localStorage.getItem('gestion_db');
      if (!dbData) return showToast("Aucune base trouvée", true);
      
      try {
        const binaryString = atob(dbData);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
        const blob = new Blob([bytes], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "gestion.db";
        document.body.appendChild(a); 
        a.click(); 
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast("Base téléchargée avec succès");
      } catch (error) {
        showToast("Erreur lors du téléchargement: " + error.message, true);
      }
    }

    async function resetDatabase() {
      if (!checkInitialized()) return;
      if (!confirm("Réinitialiser la base de production ?")) return;
      
      try {
        const response = await fetch("gestion.db");
        if (!response.ok) throw new Error("Impossible de charger gestion.db");
        
        const buffer = await response.arrayBuffer();
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        
        await localStorage.setItemAsync("gestion_db", btoa(binary));
        showToast("Base de production réinitialisée");
        updateDBSize();
      } catch (error) {
        showToast("Erreur lors de la réinitialisation: " + error.message, true);
      }
    }

    async function uploadDatabase(event) {
      if (!checkInitialized()) return;
      
      const file = event.target.files[0];
      if (!file) return;
      if (!isDbFile(file.name)) { 
        showToast("Format non valide. Utilisez .db, .sqlite ou .sqlite3", true); 
        return; 
      }
      
      const reader = new FileReader();
      reader.onload = async function(e) {
        try {
          const bytes = new Uint8Array(e.target.result);
          let binary = ""; 
          for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
          const base64 = btoa(binary);
          
          await localStorage.setItemAsync("gestion_db", base64);
          
          let list = getDbList();
          const newDb = {
            id: Date.now(), 
            name: file.name, 
            data: base64
          };
          list.push(newDb);
          
          await saveDbList(list);
          await setActiveIndex(list.length - 1);
          
          showToast(`Base "${file.name}" importée avec succès`);
          renderDbList();
          updateDBSize();
        } catch (error) {
          showToast("Erreur lors de l'importation: " + error.message, true);
        }
      };
      reader.readAsArrayBuffer(file);
      
      // Réinitialiser l'input
      event.target.value = '';
    }

    async function createNewDatabase() {
      if (!checkInitialized()) return;
      
      try {
        const response = await fetch("gestion.db");
        if (!response.ok) throw new Error("Impossible de charger le template");
        
        const buffer = await response.arrayBuffer();
        const bytes = new Uint8Array(buffer);
        let binary = ""; 
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        
        let list = getDbList();
        const newDb = {
          id: Date.now(), 
          name: `NouvelleBase_${list.length + 1}`, 
          data: base64
        };
        list.push(newDb);
        
        await saveDbList(list);
        showToast("Nouvelle base vierge créée");
        renderDbList();
      } catch (error) {
        showToast("Erreur lors de la création: " + error.message, true);
      }
    }

    async function updateFromServer() {
      if (!checkInitialized()) return;
      
      try {
        showToast("Connexion au serveur...");
        const response = await fetch(`${API_BASE_URL}/export`);
        if (!response.ok) throw new Error("Erreur HTTP " + response.status);
        
        const data = await response.json();
        const base64Db = data.db;
        
        let list = getDbList();
        const newDb = {
          id: Date.now(),
          name: `BaseServeur_${new Date().toLocaleString('fr-FR')}`,
          data: base64Db
        };
        list.push(newDb);
        
        await saveDbList(list);
        const newIndex = list.length - 1;
        await localStorage.setItemAsync("gestion_db", base64Db);
        await setActiveIndex(newIndex);
        await localStorage.setItemAsync("apiBaseUrl", "/api");
        
        renderDbList();
        updateDBSize();
        showToast("Base mise à jour depuis le serveur");
      } catch (err) {
        console.error(err);
        showToast("Erreur serveur: " + err.message, true);
      }
    }

    async function saveCurrentBeforeSwitch() {
      const idx = getActiveIndex();
      if (idx >= 0) {
        let list = getDbList();
        if (list[idx]) {
          list[idx].data = localStorage.getItem("gestion_db") || "";
          await saveDbList(list);
        }
      }
    }

    async function selectDatabase(idx) {
      if (!checkInitialized()) return;
      
      try {
        await saveCurrentBeforeSwitch();
        let list = getDbList();
        if (list[idx]) {
          await localStorage.setItemAsync("gestion_db", list[idx].data);
          await setActiveIndex(idx);
          showToast(`"${list[idx].name}" est maintenant active`);
          updateDBSize();
          renderDbList();
        }
      } catch (error) {
        showToast("Erreur lors de la sélection: " + error.message, true);
      }
    }

    async function renameDatabase(idx) {
      if (!checkInitialized()) return;
      
      let list = getDbList();
      const newName = prompt("Nouveau nom:", list[idx].name);
      if (newName && newName.trim()) { 
        list[idx].name = newName.trim(); 
        await saveDbList(list); 
        renderDbList(); 
        showToast("Base renommée");
      }
    }

    async function deleteDatabase(idx) {
      if (!checkInitialized()) return;
      if (!confirm("Supprimer cette base sauvegardée ?")) return;
      
      try {
        let list = getDbList();
        const deletedName = list[idx].name;
        list.splice(idx, 1);
        await saveDbList(list);
        
        if (idx === getActiveIndex()) { 
          await localStorage.removeItemAsync("gestion_db"); 
          await setActiveIndex(-1); 
          updateDBSize();
        }
        
        renderDbList();
        showToast(`"${deletedName}" supprimée`);
      } catch (error) {
        showToast("Erreur lors de la suppression: " + error.message, true);
      }
    }

    function renderDbList() {
      if (!APP_INITIALIZED) return;
      
      const list = getDbList();
      const active = getActiveIndex();
      const ul = document.getElementById("dbList");
      
      if (list.length === 0) {
        ul.innerHTML = '<li class="text-gray-500 text-center py-4">Aucune base sauvegardée</li>';
        return;
      }
      
      ul.innerHTML = "";
      list.forEach((db, idx) => {
        const li = document.createElement("li");
        li.className = `flex items-center justify-between border rounded p-3 ${idx === active ? 'bg-blue-50 border-blue-300' : 'hover:bg-gray-50'}`;
        li.innerHTML = `
          <div class="flex items-center space-x-3">
            <input type="radio" name="activeDb" ${idx === active ? "checked" : ""} onchange="selectDatabase(${idx})" class="text-blue-600">
            <span class="font-medium ${idx === active ? 'text-blue-600' : ''}">${db.name}</span>
            ${idx === active ? '<span class="text-xs bg-blue-100 text-blue-600 px-2 py-1 rounded">Active</span>' : ''}
          </div>
          <div class="space-x-2">
            <button onclick="renameDatabase(${idx})" class="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600 transition" title="Renommer">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="deleteDatabase(${idx})" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 transition" title="Supprimer">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        ul.appendChild(li);
      });
    }

    function updateDBSize() {
      const dbData = localStorage.getItem('gestion_db');
      if (dbData) {
        const sizeMB = (dbData.length / 1024 / 1024).toFixed(2);
        document.getElementById("dbSize").textContent = `Taille: ${sizeMB} MB`;
      } else {
        document.getElementById("dbSize").textContent = "Taille: Aucune base active";
      }
    }

    // Initialisation au chargement
    document.addEventListener("DOMContentLoaded", initializeApp);
  </script>
</body>
</html>
