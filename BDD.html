<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gestion Base de Données - FirePoz</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    .toast-in { animation: toastIn 0.5s both; }
    .toast-out { animation: toastOut 0.5s both; }
    @keyframes toastIn { from { opacity:0; transform:translateY(40px);} to { opacity:1; transform:translateY(0);} }
    @keyframes toastOut { from { opacity:1; transform:translateY(0);} to { opacity:0; transform:translateY(40px);} }
  </style>
</head>
<body class="bg-gray-100 min-h-screen">

  <!-- ⚡ Gestionnaire IndexedDB amélioré pour multi-bases -->
  <script>
    class DatabaseManager {
      constructor() {
        this.DB_NAME = "FirePozMultiDB";
        this.STORE_NAME = "databases";
        this.CONFIG_STORE = "config";
        this.dbPromise = this.initDB();
        this.currentDb = null;
        this.activeDbId = null;
      }

      async initDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(this.DB_NAME, 1);
          req.onupgradeneeded = e => {
            const db = e.target.result;
            // Store pour les bases de données
            if (!db.objectStoreNames.contains(this.STORE_NAME)) {
              db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
            }
            // Store pour la configuration
            if (!db.objectStoreNames.contains(this.CONFIG_STORE)) {
              db.createObjectStore(this.CONFIG_STORE);
            }
          };
          req.onsuccess = e => resolve(e.target.result);
          req.onerror = e => reject(e);
        });
      }

      async saveDatabase(id, name, data) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readwrite");
          const store = tx.objectStore(this.STORE_NAME);
          const dbEntry = {
            id: id,
            name: name,
            data: data,
            lastModified: Date.now()
          };
          store.put(dbEntry);
          tx.oncomplete = () => resolve(true);
          tx.onerror = reject;
        });
      }

      async getDatabase(id) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readonly");
          const store = tx.objectStore(this.STORE_NAME);
          const req = store.get(id);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = reject;
        });
      }

      async getAllDatabases() {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readonly");
          const store = tx.objectStore(this.STORE_NAME);
          const req = store.getAll();
          req.onsuccess = () => resolve(req.result || []);
          req.onerror = reject;
        });
      }

      async deleteDatabase(id) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.STORE_NAME, "readwrite");
          const store = tx.objectStore(this.STORE_NAME);
          store.delete(id);
          tx.oncomplete = () => resolve(true);
          tx.onerror = reject;
        });
      }

      async setActiveDatabase(id) {
        this.activeDbId = id;
        const dbEntry = await this.getDatabase(id);
        if (dbEntry) {
          this.currentDb = dbEntry.data;
          await this.setConfig('activeDbId', id);
          return true;
        }
        return false;
      }

      async getActiveDatabase() {
        if (!this.activeDbId) {
          this.activeDbId = await this.getConfig('activeDbId');
        }
        return this.currentDb;
      }

      async getActiveDatabaseId() {
        if (!this.activeDbId) {
          this.activeDbId = await this.getConfig('activeDbId');
        }
        return this.activeDbId;
      }

      async setConfig(key, value) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.CONFIG_STORE, "readwrite");
          const store = tx.objectStore(this.CONFIG_STORE);
          store.put(value, key);
          tx.oncomplete = () => resolve(true);
          tx.onerror = reject;
        });
      }

      async getConfig(key) {
        const db = await this.dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(this.CONFIG_STORE, "readonly");
          const store = tx.objectStore(this.CONFIG_STORE);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = reject;
        });
      }

      async updateCurrentDatabase(data) {
        if (this.activeDbId && this.currentDb !== data) {
          this.currentDb = data;
          const dbEntry = await this.getDatabase(this.activeDbId);
          if (dbEntry) {
            await this.saveDatabase(this.activeDbId, dbEntry.name, data);
          }
        }
      }
    }

    // Instance globale du gestionnaire
    const dbManager = new DatabaseManager();

    // Compatibility layer pour localStorage
    window.localStorage = {
      async getItem(key) {
        if (key === 'gestion_db') {
          return await dbManager.getActiveDatabase();
        }
        return await dbManager.getConfig(key);
      },
      async setItem(key, value) {
        if (key === 'gestion_db') {
          await dbManager.updateCurrentDatabase(value);
        } else {
          await dbManager.setConfig(key, value);
        }
      },
      // Version synchrone pour compatibilité (utilise le cache)
      getItemSync(key) {
        if (key === 'gestion_db') {
          return dbManager.currentDb;
        }
        return null; // Pour les autres clés, utiliser la version async
      },
      setItemSync(key, value) {
        if (key === 'gestion_db') {
          dbManager.currentDb = value;
        }
      }
    };
  </script>

  <!-- Navbar -->
  <nav class="bg-indigo-600 text-white p-4 shadow-md">
    <div class="container mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-bold">
        <i class="fas fa-database mr-2"></i>Gestion Base de Données
      </h1>
      <button onclick="goHome()" class="bg-white text-indigo-600 px-4 py-2 rounded-md hover:bg-gray-200">
        <i class="fas fa-home mr-2"></i>Accueil
      </button>
    </div>
  </nav>

  <div class="container mx-auto px-4 py-8">
    <!-- Gestion Base de Données -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4">
        <i class="fas fa-database mr-2 text-indigo-500"></i>Outils Base de Données
      </h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <button onclick="downloadDatabase()" class="w-full bg-green-600 text-white px-4 py-3 rounded-md hover:bg-green-700 transition">
          <i class="fas fa-file-download mr-2"></i>Télécharger gestion.db
        </button>
        <button onclick="resetDatabase()" class="w-full bg-red-600 text-white px-4 py-3 rounded-md hover:bg-red-700 transition">
          <i class="fas fa-trash mr-2"></i>Réinitialiser la Base
        </button>
        <label class="w-full bg-blue-600 text-white px-4 py-3 rounded-md hover:bg-blue-700 transition text-center cursor-pointer">
          <i class="fas fa-upload mr-2"></i>Charger depuis fichier
          <input type="file" id="uploadDb" accept=".db,.sqlite,.sqlite3" class="hidden" onchange="uploadDatabase(event)">
        </label>
        <button onclick="createNewDatabase()" class="w-full bg-indigo-600 text-white px-4 py-3 rounded-md hover:bg-indigo-700 transition">
          <i class="fas fa-plus-circle mr-2"></i>Nouvelle Base (vierge)
        </button>
        <button onclick="updateFromServer()" class="w-full bg-yellow-600 text-white px-4 py-3 rounded-md hover:bg-yellow-700 transition">
          <i class="fas fa-cloud-download-alt mr-2"></i>Mettre à jour depuis serveur
        </button>
      </div>
      <div class="mt-4 text-sm text-gray-600">
        <p><i class="fas fa-info-circle mr-2"></i>La base de production est stockée dans IndexedDB</p>
        <p id="dbSize" class="mt-2">Taille: Calcul en cours...</p>
        <p id="activeDb" class="mt-2 font-semibold text-indigo-600">Base active: Aucune</p>
      </div>
    </div>

    <!-- Liste des bases sauvegardées -->
    <div class="bg-white rounded-lg shadow-md p-6">
      <h2 class="text-xl font-semibold mb-4">
        <i class="fas fa-archive mr-2 text-indigo-500"></i>Bases Sauvegardées
      </h2>
      <ul id="dbList" class="space-y-3"></ul>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="fixed bottom-4 right-4 hidden">
    <div class="flex items-center px-6 py-3 rounded-md shadow-lg">
      <i id="toastIcon" class="mr-2"></i>
      <span id="toastMessage"></span>
    </div>
  </div>

  <script>
    let API_BASE_URL = 'https://hicham03041979.onrender.com';

    async function initApp() {
      API_BASE_URL = await dbManager.getConfig('apiBaseUrl') || API_BASE_URL;
      await loadActiveDatabase();
      await renderDbList();
      updateDBSize();
    }

    async function loadActiveDatabase() {
      const activeId = await dbManager.getActiveDatabaseId();
      if (activeId) {
        await dbManager.setActiveDatabase(activeId);
        const dbEntry = await dbManager.getDatabase(activeId);
        if (dbEntry) {
          document.getElementById("activeDb").textContent = `Base active: ${dbEntry.name}`;
        }
      }
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toastMessage');
      const toastIcon = document.getElementById('toastIcon');
      toast.className = isError
        ? 'fixed bottom-4 right-4 flex items-center bg-red-500 text-white px-6 py-3 rounded-md shadow-lg toast-in'
        : 'fixed bottom-4 right-4 flex items-center bg-green-500 text-white px-6 py-3 rounded-md shadow-lg toast-in';
      toastIcon.className = isError ? 'fas fa-exclamation-circle mr-2' : 'fas fa-check-circle mr-2';
      toastMessage.textContent = message;
      toast.classList.remove('hidden');
      setTimeout(() => {
        toast.classList.remove('toast-in');
        toast.classList.add('toast-out');
        setTimeout(() => toast.classList.add('hidden'), 500);
      }, 3000);
    }

    function isDbFile(name) { return /\.(db|sqlite|sqlite3)$/i.test(name); }
    function goHome() { window.location.href = "index.html"; }

    async function downloadDatabase() {
      const dbData = await dbManager.getActiveDatabase();
      if (!dbData) return showToast("Aucune base active trouvée", true);
      
      const binaryString = atob(dbData);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
      const blob = new Blob([bytes], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "gestion.db";
      document.body.appendChild(a); 
      a.click(); 
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast("Base téléchargée");
    }

    async function resetDatabase() {
      if (!confirm("Réinitialiser la base active ?")) return;
      
      try {
        const response = await fetch("gestion.db");
        const buffer = await response.arrayBuffer();
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        
        const activeId = await dbManager.getActiveDatabaseId();
        if (activeId) {
          const dbEntry = await dbManager.getDatabase(activeId);
          await dbManager.saveDatabase(activeId, dbEntry.name, base64);
          await dbManager.setActiveDatabase(activeId);
        }
        
        showToast("Base active réinitialisée");
        updateDBSize();
      } catch (error) {
        showToast("Erreur lors de la réinitialisation", true);
      }
    }

    async function uploadDatabase(event) {
      const file = event.target.files[0];
      if (!file) return;
      if (!isDbFile(file.name)) { 
        showToast("Format non valide", true); 
        return; 
      }
      
      const reader = new FileReader();
      reader.onload = async function(e) {
        const bytes = new Uint8Array(e.target.result);
        let binary = ""; 
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        
        const newId = Date.now();
        await dbManager.saveDatabase(newId, file.name, base64);
        await dbManager.setActiveDatabase(newId);
        
        showToast(`Base "${file.name}" importée et activée`);
        await renderDbList();
        updateDBSize();
        document.getElementById("activeDb").textContent = `Base active: ${file.name}`;
      };
      reader.readAsArrayBuffer(file);
    }

    async function createNewDatabase() {
      try {
        const response = await fetch("gestion.db");
        const buffer = await response.arrayBuffer();
        const bytes = new Uint8Array(buffer);
        let binary = ""; 
        for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        
        const databases = await dbManager.getAllDatabases();
        const newId = Date.now();
        const newName = `NouvelleBase_${databases.length + 1}`;
        
        await dbManager.saveDatabase(newId, newName, base64);
        showToast("Nouvelle base vierge créée");
        await renderDbList();
      } catch (error) {
        showToast("Erreur lors de la création", true);
      }
    }

    async function updateFromServer() {
      try {
        const response = await fetch(`${API_BASE_URL}/export`);
        if (!response.ok) throw new Error("Erreur HTTP " + response.status);
        
        const data = await response.json();
        const base64Db = data.db;
        
        const databases = await dbManager.getAllDatabases();
        const newId = Date.now();
        const newName = `BaseServeur_${databases.length + 1}`;
        
        await dbManager.saveDatabase(newId, newName, base64Db);
        await dbManager.setActiveDatabase(newId);
        await dbManager.setConfig("apiBaseUrl", "/api");
        
        await renderDbList();
        updateDBSize();
        document.getElementById("activeDb").textContent = `Base active: ${newName}`;
        showToast("✅ Base mise à jour et activée. Mode local activé !");
      } catch (err) {
        console.error(err);
        showToast("❌ Erreur : " + err.message, true);
      }
    }

    async function selectDatabase(id) {
      const success = await dbManager.setActiveDatabase(id);
      if (success) {
        const dbEntry = await dbManager.getDatabase(id);
        showToast(`"${dbEntry.name}" est maintenant la base de production`);
        document.getElementById("activeDb").textContent = `Base active: ${dbEntry.name}`;
        updateDBSize();
        await renderDbList();
      } else {
        showToast("Erreur lors de la sélection", true);
      }
    }

    async function renameDatabase(id) {
      const dbEntry = await dbManager.getDatabase(id);
      const newName = prompt("Nouveau nom:", dbEntry.name);
      if (newName && newName !== dbEntry.name) { 
        await dbManager.saveDatabase(id, newName, dbEntry.data);
        const activeId = await dbManager.getActiveDatabaseId();
        if (id === activeId) {
          document.getElementById("activeDb").textContent = `Base active: ${newName}`;
        }
        await renderDbList(); 
      }
    }

    async function deleteDatabase(id) {
      const dbEntry = await dbManager.getDatabase(id);
      if (!confirm(`Supprimer la base "${dbEntry.name}" ?`)) return;
      
      await dbManager.deleteDatabase(id);
      const activeId = await dbManager.getActiveDatabaseId();
      
      if (id === activeId) {
        dbManager.currentDb = null;
        dbManager.activeDbId = null;
        await dbManager.setConfig('activeDbId', null);
        document.getElementById("activeDb").textContent = "Base active: Aucune";
      }
      
      await renderDbList();
      updateDBSize();
    }

    async function renderDbList() {
      const databases = await dbManager.getAllDatabases();
      const activeId = await dbManager.getActiveDatabaseId();
      const ul = document.getElementById("dbList");
      ul.innerHTML = "";
      
      if (databases.length === 0) {
        ul.innerHTML = "<li class='text-gray-500 text-center py-4'>Aucune base sauvegardée</li>";
        return;
      }

      databases.forEach((db) => {
        const li = document.createElement("li");
        li.className = "flex items-center justify-between border rounded p-3" + 
                      (db.id === activeId ? " bg-indigo-50 border-indigo-300" : "");
        
        const date = new Date(db.lastModified).toLocaleDateString();
        li.innerHTML = `
          <div class="flex items-center space-x-3">
            <input type="radio" name="activeDb" ${db.id === activeId ? "checked" : ""} 
                   onchange="selectDatabase(${db.id})">
            <div>
              <span class="font-medium">${db.name}</span>
              <div class="text-sm text-gray-500">Modifié le ${date}</div>
            </div>
          </div>
          <div class="space-x-2">
            <button onclick="renameDatabase(${db.id})" 
                    class="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="deleteDatabase(${db.id})" 
                    class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        ul.appendChild(li);
      });
    }

    async function updateDBSize() {
      const dbData = await dbManager.getActiveDatabase();
      if (dbData) {
        const sizeMB = (dbData.length / 1024 / 1024).toFixed(2);
        document.getElementById("dbSize").textContent = `Taille: ${sizeMB} MB`;
      } else {
        document.getElementById("dbSize").textContent = "Taille: 0 MB";
      }
    }

    // Initialisation de l'application
    document.addEventListener("DOMContentLoaded", initApp);
  </script>
</body>
</html>